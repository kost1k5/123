# Руководство для агентов по проекту «Хроно-Платформер»

Этот документ содержит ключевую информацию об архитектуре и принципах разработки данного проекта. Он предназначен для помощи другим агентам или разработчикам в понимании кодовой базы и внесении изменений.

## 1. Ключевые архитектурные принципы

Проект строго следует модульному и компонентному подходу, заложенному в первоначальном архитектурном плане.

*   **Разделение ответственности:**
    *   **`/src/engine`**: Содержит ядро движка. Эти классы (`AssetManager`, `InputHandler`, `TimeManager` и т.д.) не должны содержать логику, специфичную для «Хроно-Платформера». Они должны быть универсальными.
    *   **`/src/game`**: Содержит классы, описывающие саму игру (`Player`, `Level`, `UI`). Они используют компоненты движка.
    *   **`/src/utils`**: Содержит простые, чистые функции и классы без состояния (например, `Vec2`, `checkAABBCollision`).

*   **ES6 Модули:** Каждый класс находится в своем собственном файле и использует синтаксис `import`/`export`. Это стандарт для всего проекта.

*   **Управление через менеджеры:** Вместо глобальных переменных или разрозненных функций для управления ключевыми подсистемами используются специализированные классы-менеджеры: `AssetManager`, `AudioManager`, `InputHandler`, `SaveManager`, `TimeManager`. Вся конфигурация и инициализация этих менеджеров происходит в `main.js`.

*   **Data-Driven Design (Управление данными):**
    *   **Уровни:** Геометрия уровней и начальное положение сущностей полностью определяются в `JSON` файлах в `assets/levels/`. Класс `Level` отвечает за их загрузку и парсинг. Не вносите изменения в геометрию уровня напрямую в коде.
    *   **Анимации:** Параметры анимации (номер ряда, количество кадров, скорость) определяются в виде объекта в конструкторе класса `Player` и передаются в компонент `Sprite`.

## 2. Игровой цикл

Основной цикл находится в `src/main.js` и использует **fixed-timestep** (фиксированный временной шаг).
*   `update(timestep)`: Вызывается с фиксированным интервалом (60 раз в секунду). Вся игровая логика, физика и изменения состояния должны происходить здесь.
*   `draw()`: Вызывается так часто, как позволяет `requestAnimationFrame`. Здесь происходит только отрисовка текущего состояния. **Не изменяйте состояние игры в функции `draw()`**.

## 3. Система столкновений

Столкновения обрабатываются в методе `Player.update()` и `Player.handleCollisions()`.
*   **Алгоритм:** AABB (Axis-Aligned Bounding Box).
*   **Разрешение:** Используется критически важный метод **разделения по осям**. Горизонтальное движение и столкновения рассчитываются и разрешаются **полностью до** начала расчета вертикального движения. Это предотвращает застревание в углах и просачивание. При отладке физики в первую очередь проверяйте соблюдение этого порядка.

## 4. Внесение изменений

*   **Добавление новой сущности:** Создайте новый класс в `/src/game`, по аналогии с `Player`. Добавьте логику его создания в `main.js` после загрузки уровня.
*   **Добавление нового состояния игрока:** Измените `Player.js`. Добавьте новые флаги состояния и обновите `updateAnimationState()` для переключения анимации в `Sprite`.
*   **Изменение уровня:** Редактируйте соответствующий `.json` файл в `assets/levels/`.
